#pragma config(Sensor, S1,		 sright,							sensorSONAR)
#pragma config(Sensor, S4,		 sleft,								sensorSONAR)
//*!!Code automatically generated by 'ROBOTC' configuration wizard							 !!*//

//autonomous
int left1[50];
int right1[50];
int left2[50];
int right2[50];

int left11[50];
int right11[50];
int left22[50];
int right22[50];
int tolerance=225;
int angle=12;
int max=600;

task shoot(){
  /*
  PlaySound(soundBeepBeep);
  wait1Msec(200);
  StopTask(shoot);
  */
int r=motor[motorB];
int l=motor[motorC];
motor[motorB]=0;
motor[motorC]=0;





////
  nMotorEncoder[motorA] = 0;
  nMotorEncoderTarget[motorA] = 360;
  motor[motorA] = 100;
  while (nMotorRunState[motorA] != runStateIdle) //while the encoder wheel turns one revolution
  {
    // This condition waits for motors B + C to come to an idle position. Both motors stop
    // and then jumps out of the loop
  }

  motor[motorA] = 0;
  //////


  motor[motorB]=r;
  motor[motorC]=l;
  StopTask(shoot);

}

void scan(){
  nMotorEncoder[motorB] = 0;
  nMotorEncoder[motorC] = 0;
  motor[motorC] = 50;
  motor[motorB] = -50;


  for(int i=angle;i<=max;i+=angle){



    while ((nMotorEncoder[motorC] < i) || (nMotorEncoder[motorB] > -i ) ){

    }
    //while the encoder wheel turns one revolution



    int x=(i/angle)-1;
    left1[x]=SensorValue(sleft);
    right1[x]=SensorValue(sright);
    /*
    nxtEraseRect(0, 62, 62, 0);

    int f=nMotorEncoder[motorC];
    nxtDisplayStringAt(10, 40, "%d %d", f, nMotorEncoder[motorB]);
    */

  }
  motor[motorB] = 0;
  motor[motorC] = 0;
  nMotorEncoder[motorB] = 0;
  nMotorEncoder[motorC] = 0;
  motor[motorC] = -50;
  motor[motorB] = 50;

  for(int i=angle;i<=max;i+=angle){

    while ((nMotorEncoder[motorC] > -i) && (nMotorEncoder[motorB] <i ) ) //while the encoder wheel turns one revolution
    {
      // This condition waits for motors B + C to come to an idle position. Both motors stop
      // and then jumps out of the loop
    }


    int x=(i/angle)-1;
    left2[x]=SensorValue(sleft);
    right2[x]=SensorValue(sright);

  }
  motor[motorB] = 0;
  motor[motorC] = 0;
}

void compare(){
  nMotorEncoder[motorB] = 0;
  nMotorEncoder[motorC] = 0;
  motor[motorC] = 50;
  motor[motorB] = -50;


  for(int i=angle;i<=max;i+=angle){


    while ((nMotorEncoder[motorC] < i) && (nMotorEncoder[motorB] > -i ) ) //while the encoder wheel turns one revolution
    {
      // This condition waits for motors B + C to come to an idle position. Both motors stop
      // and then jumps out of the loop
    }


    int x=(i/angle)-1;
    left11[x]=SensorValue(sleft);
    right11[x]=SensorValue(sright);

/*((left11 > left1+tolerance) || (right11 > right1+tolerance))  || ((left11 < left1-tolerance)|| (right11 < right1-tolerance))*/
   if((left11[x]+right11[x])>((left1[x]+right1[x])+tolerance) || (left11[x]+right11[x])<((left1[x]+right1[x])-tolerance)){
       StartTask(shoot);
   }
/*
    if(x!=0){//////////////
        int aa=((left11[x]+right11[x]+left11[x-1]+right11[x-1])/2);
      int ab=(((left1[x]+right1[x]+left1[x-1]+right1[x-1])/2)+tolerance);

      int bb=(((left1[x]+right1[x]+left1[x-1]+right1[x-1])/2)-tolerance);
      if(aa>ab || aa<bb){
       StartTask(shoot);
      }
    }
    else{
      if((left11[x]+right11[x])>((left1[x]+right1[x])+tolerance) || (left11[x]+right11[x])<((left1[x]+right1[x])-tolerance)){
         StartTask(shoot);
      }
    }
    */
  }
  motor[motorB] = 0;
  motor[motorC] = 0;
  nMotorEncoder[motorB] = 0;
  nMotorEncoder[motorC] = 0;
  motor[motorC] = -50;
  motor[motorB] = 50;

  for(int i=angle;i<=max;i+=angle){

    while ((nMotorEncoder[motorC] > -i) && (nMotorEncoder[motorB] < i ) ) //while the encoder wheel turns one revolution
    {
      // This condition waits for motors B + C to come to an idle position. Both motors stop
      // and then jumps out of the loop
    }


    int x=(i/angle)-1;
    left22[x]=SensorValue(sleft);
    right22[x]=SensorValue(sright);
      if((left22[x]+right22[x])>((left2[x]+right2[x])+tolerance) || (left22[x]+right22[x])<((left2[x]+right2[x])-tolerance)){
      StartTask(shoot);
   }

  }
  motor[motorB] = 0;
  motor[motorC] = 0;
  /*
  nMotorEncoder[motorB] = 0;
  nMotorEncoder[motorC] = 0;
  for(int i=3;i<=150;i+=3){

  nMotorEncoderTarget[motorB] = i;
  nMotorEncoderTarget[motorC] = i;
  motor[motorC] = 100;
  motor[motorB] = -100;
  while (nMotorRunState[motorC] != runStateIdle && nMotorRunState[motorB] != runStateIdle) //while the encoder wheel turns one revolution
  {
  // This condition waits for motors B + C to come to an idle position. Both motors stop
  // and then jumps out of the loop
  }

  motor[motorB] = 0;
  motor[motorC] = 0;
  int x=(i/3)-1;
  left11[x]=SensorValue(sleft);
  right11[x]=SensorValue(sright);
  if(((left11 > left1+tolerance) && (right11 > right1+tolerance))  || ((left11 < left1-tolerance)&& (right11 < right1-tolerance))){
  fire();
  }

  }
  nMotorEncoder[motorB] = 0;
  nMotorEncoder[motorC] = 0;
  for(int i=3;i<=150;i+=3){

  nMotorEncoderTarget[motorB] = i;
  nMotorEncoderTarget[motorC] = i;
  motor[motorC] = -100;
  motor[motorB] = 100;
  while (nMotorRunState[motorC] != runStateIdle && nMotorRunState[motorB] != runStateIdle) //while the encoder wheel turns one revolution
  {
  // This condition waits for motors B + C to come to an idle position. Both motors stop
  // and then jumps out of the loop
  }

  motor[motorB] = 0;
  motor[motorC] = 0;
  int x=(i/3)-1;
  left22[x]=SensorValue(sleft);
  right22[x]=SensorValue(sright);
  if(((left22 > left2+tolerance) && (right22 > right2+tolerance))  || ((left22 < left2-tolerance)&& (right22 < right2-tolerance))){
  fire();
  }

  }
  */
}


task move(){

}
task main(){
 wait1Msec(15000);
  PlaySound(soundBeepBeep);
  scan();
  while(1){
     compare();
     for(int i=0;i<50;i++){
       right1[i]=right11[i];
       left1[i]=left11[i];
       right2[i]=right22[i];
       left2[i]=left22[i];
     }
  }


  wait1Msec(2000);

}
